package action;

import lejos.hardware.motor.Motor;
import lejos.robotics.RegulatedMotor;
import lejos.robotics.chassis.Wheel;
import lejos.robotics.chassis.WheeledChassis;
import lejos.robotics.localization.OdometryPoseProvider;
import lejos.robotics.localization.PoseProvider;
import lejos.robotics.navigation.MovePilot;
import lejos.robotics.navigation.Pose;

/**
 * Classe Deplacement permettant de g�rer les d�placements d'un robot 
 * � l'aide d'un ch�ssis diff�rentiel. Cette classe propose des m�thodes 
 * pour avancer, tourner et ajuster les vitesses lin�aires et angulaires.
 * 
 * <p><strong>Objectifs du Module</strong></p>
 * <ul>
 *   <li>G�rer les mouvements du robot de mani�re pr�cise et efficace.</li>
 *   <li>Permettre des rotations ajust�es pour compenser les erreurs d'odom�trie.</li>
 *   <li>Faciliter la modification des vitesses lin�aires et angulaires en fonction des besoins du projet.</li>
 *   <li>Assurer une navigation autonome et r�active face aux obstacles et aux changements de direction.</li>
 * </ul>
 * 
 * <p><strong>Relations d�utilisation avec d�Autres Modules</strong></p>
 * <ul>
 *   <li>La classe {@code Deplacement} est utilis�e par {@code Agent}, {@code CapteurUltrason}, {@code CapteurCouleur}, {@code Pince}, et {@code Test_deplacement} pour contr�ler les mouvements du robot.</li>
 * </ul>
 * 
 * <p><strong>Modules Utilis�s par ce Module</strong></p>
 * <ul>
 *   <li>{@code lejos.hardware.motor.Motor} : Fournit l'acc�s aux moteurs du robot.</li>
 *   <li>{@code lejos.robotics.chassis.Wheel} : Repr�sente les roues du robot.</li>
 *   <li>{@code lejos.robotics.chassis.WheeledChassis} : Permet de d�finir le ch�ssis du robot avec ses roues.</li>
 *   <li>{@code lejos.robotics.localization.OdometryPoseProvider} : Fournit les informations de position bas�es sur l'odom�trie.</li>
 *   <li>{@code lejos.robotics.navigation.MovePilot} : Contr�le les mouvements du robot en utilisant le ch�ssis d�fini.</li>
 * </ul>
 * 
 * <p><strong>Modules Utilisant ce Module</strong></p>
 * <ul>
 *   <li>{@code Agent} : Utilise {@code Deplacement} pour g�rer les d�placements du robot.</li>
 *   <li>{@code CapteurUltrason} : Utilise {@code Deplacement} pour ajuster les mouvements en fonction des d�tections de distance.</li>
 *   <li>{@code CapteurCouleur} : Utilise {@code Deplacement} pour ajuster les trajectoires en fonction des couleurs d�tect�es.</li>
 *   <li>{@code Pince} : Peut utiliser {@code Deplacement} pour coordonner les mouvements lors de la manipulation des objets.</li>
 *   <li>{@code Test_deplacement} : Utilise {@code Deplacement} pour tester les diff�rentes m�thodes de d�placement.</li>
 * </ul>
 * 
 * <p><strong>D�finitions de Types</strong></p>
 * <ul>
 *   <li><strong>DIAMETRE</strong> : Diam�tre des roues du robot en centim�tres.</li>
 *   <li><strong>pilot</strong> : Instance de {@code MovePilot} utilis�e pour contr�ler les mouvements du robot.</li>
 *   <li><strong>poseProvider</strong> : Instance de {@code PoseProvider} utilis�e pour obtenir la position et l'orientation du robot.</li>
 * </ul>
 * 
 * <p><strong>Proc�dures Externes</strong></p>
 * <ul>
 *   <li>{@code getDirection()} : Retourne la direction actuelle du robot en degr�s.</li>
 *   <li>{@code getPilot()} : Retourne l'instance de {@code MovePilot} utilis�e pour le contr�le des mouvements.</li>
 *   <li>{@code avancerSync(double distance)} : Fait avancer le robot sur une distance sp�cifi�e en mode synchrone.</li>
 *   <li>{@code avancer(double distance)} : Fait avancer le robot sur une distance sp�cifi�e en mode asynchrone.</li>
 *   <li>{@code tournerSync(double angleToTurn)} : Fait tourner le robot d'un angle sp�cifi� en mode synchrone avec ajustement des erreurs de rotation.</li>
 *   <li>{@code tourner(double angleToTurn)} : Fait tourner le robot d'un angle sp�cifi� en mode asynchrone avec ajustement des erreurs de rotation.</li>
 *   <li>{@code tourner(double angleToTurn, boolean heading)} : M�thode sp�cialis�e pour les rotations n�cessitant une interaction avec le {@code PoseProvider}.</li>
 *   <li>{@code modifVitRot(double s)} : Modifie la vitesse angulaire du robot (rotation) en degr�s par seconde.</li>
 *   <li>{@code modifVitLin(double s)} : Modifie la vitesse lin�aire du robot en centim�tres par seconde.</li>
 *   <li>{@code isMoving()} : V�rifie si le robot est actuellement en mouvement.</li>
 *   <li>{@code stop()} : Arr�te imm�diatement tous les mouvements du robot.</li>
 * </ul>
 * 
 * <p><strong>Variables Externes</strong></p>
 * <ul>
 *   <li>{@code DIAMETRE} : Constante d�finissant le diam�tre des roues du robot.</li>
 *   <li>{@code pilot} : Instance de {@code MovePilot} utilis�e pour contr�ler les mouvements du robot.</li>
 *   <li>{@code poseProvider} : Instance de {@code PoseProvider} utilis�e pour obtenir la position et l'orientation du robot.</li>
 * </ul>
 * 
 * @version 1.0
 * @author 
 *   AIT EL HADJ Anas
 * @author 
 *   AMACHAT Yousra
 * @author 
 *   HALILY Youssef
 * @author 
 *   NGUIRANE Mari�me
 * @author 
 *   TAMSOURI Mohammed
 */
public class Deplacement {

    // Diam�tre des roues du robot en centim�tres
    private static final double DIAMETRE = 5.6;
    private MovePilot pilot; // Contr�leur de mouvement
    private PoseProvider poseProvider; // Fournisseur de position bas� sur l'odom�trie

    /**
     * Constructeur de la classe Deplacement. 
     * Initialise les roues, le ch�ssis, le pilote et le fournisseur de position.
     */
    public Deplacement() {
        Wheel roue1 = WheeledChassis.modelWheel((RegulatedMotor) Motor.B, DIAMETRE).offset(-6.2);
        Wheel roue2 = WheeledChassis.modelWheel((RegulatedMotor) Motor.A, DIAMETRE).offset(6.2);
        WheeledChassis chassis = new WheeledChassis(new Wheel[] { roue1, roue2 }, WheeledChassis.TYPE_DIFFERENTIAL);
        pilot = new MovePilot(chassis);
        poseProvider = new OdometryPoseProvider(pilot); // Initialisation du PoseProvider
    }

    /**
     * Retourne la direction actuelle du robot en degr�s.
     * 
     * @return La direction (orientation) du robot en degr�s.
     */
    public float getDirection() {
        Pose pose = poseProvider.getPose();
        return pose.getHeading();
    }

    /**
     * Retourne l'instance de MovePilot utilis�e pour le contr�le des mouvements.
     * 
     * @return L'instance MovePilot.
     */
    public MovePilot getPilot() {
        return pilot;
    }

    /**
     * Fait avancer le robot sur une distance sp�cifi�e (mode synchrone).
     * 
     * @param distance Distance en centim�tres que le robot doit parcourir.
     */
    public void avancerSync(double distance) {
        pilot.travel(distance, true);
    }

    /**
     * Fait avancer le robot sur une distance sp�cifi�e (mode asynchrone).
     * 
     * @param distance Distance en centim�tres que le robot doit parcourir.
     */
    public void avancer(double distance) {
        pilot.travel(distance);
    }

    /**
     * Fait tourner le robot d'un angle sp�cifi� (mode synchrone).
     * Ajuste automatiquement les valeurs d'angle pour compenser les erreurs de rotation.
     * 
     * @param angleToTurn Angle en degr�s � parcourir.
     */
    public void tournerSync(double angleToTurn) {
        this.modifVitRot(50);
        if (angleToTurn > 0) {
            angleToTurn += 13; // Ajustement pour les rotations dans le sens antihoraire
        } else if (angleToTurn < 0) {
            angleToTurn += 4; // Ajustement pour les rotations dans le sens horaire
        }
        pilot.rotate(angleToTurn, true);
    }

    /**
     * Fait tourner le robot d'un angle sp�cifi� (mode asynchrone).
     * Ajuste automatiquement les valeurs d'angle pour compenser les erreurs de rotation.
     * 
     * @param angleToTurn Angle en degr�s � parcourir.
     */
    public void tourner(double angleToTurn) {
        this.modifVitRot(50);
        if (angleToTurn > 0) {
            angleToTurn += 9; // Ajustement pour les rotations dans le sens antihoraire
        } else if (angleToTurn < 0) {
            angleToTurn += 3; // Ajustement pour les rotations dans le sens horaire
        }
        pilot.rotate(angleToTurn);
    }

    /**
     * M�thode sp�cialis�e pour les rotations n�cessitant une interaction avec le poseProvider
     * (par exemple en cas d'erreurs de direction). Peut fonctionner en mode ajust� ou simple.
     * 
     * @param angleToTurn Angle en degr�s � parcourir.
     * @param heading Si true, ajuste l'angle pour compenser les erreurs d'odom�trie.
     */
    public void tourner(double angleToTurn, boolean heading) {
        if (heading) {
            if (angleToTurn > 0) {
                angleToTurn += 13; // Ajustement pour les rotations dans le sens antihoraire
            } else if (angleToTurn < 0) {
                angleToTurn -= 2; // Ajustement pour les rotations dans le sens horaire
            }
            pilot.rotate(angleToTurn);
        } else {
            tourner(angleToTurn);
        }
    }

    /**
     * Modifie la vitesse angulaire du robot (rotation) en degr�s par seconde.
     * 
     * @param s Nouvelle vitesse angulaire.
     */
    public void modifVitRot(double s) {
        pilot.setAngularSpeed(s);
    }

    /**
     * Modifie la vitesse lin�aire du robot en centim�tres par seconde.
     * 
     * @param s Nouvelle vitesse lin�aire.
     */
    public void modifVitLin(double s) {
        pilot.setLinearSpeed(s);
    }

    /**
     * V�rifie si le robot est actuellement en mouvement.
     * 
     * @return {@code true} si le robot est en mouvement, {@code false} sinon.
     */
    public boolean isMoving() {
        return pilot.isMoving();
    }

    /**
     * Arr�te imm�diatement tous les mouvements du robot.
     */
    public void stop() {
        pilot.stop();
    }
}
